# -*- Makefile -*- for Dungeon Crawl (unix)

#
# Modified for Crawl Reference by $Author$ on $Date$
#

GAME = crawl

# this file contains a list of the libraries.
# it will make a variable called OBJECTS that contains all the libraries
include makefile.obj

OBJECTS += libunix.o

CXX = g++
DELETE = rm -f
COPY = cp
OS_TYPE = UNIX

# Change this to y if you want to use Unicode glyphs in the map, and you have
# libncursesw available.
UNICODE_GLYPHS = n

# If you have lex and yacc, set DOYACC to y (lowercase y).
DOYACC := y

# Permissions to set on the game executable.
MCHMOD := 2755

# Permissions to set on the save directory.
MCHMOD_SAVEDIR := 775

# The user:group to install the game as. 
INSTALL_UGRP := games:games

INSTALLDIR   := /usr/games/crawl

# If you're installing Crawl for multiple users, you *must* set this to a
# valid path before building Crawl. This is not necessary if you are building
# Crawl for a single user.

# SAVEDIR := /usr/games/crawl/saves/
# DATADIR := /usr/games/crawl/data/

LEX  := flex
YACC := bison -y

ifeq ($(UNICODE_GLYPHS),y)
# Include path for (n)curses with Unicode support.
INCLUDES = -I/usr/include/ncursesw

# Your ncurses library may include Unicode support, and you may not have a
# separate libncursesw; in that case, change this line accordingly.
LIBCURS  = ncursesw
EXTRA_FLAGS += -DUNICODE_GLYPHS

# The standard ncurses library also supports Unicode on Mac OS/Darwin.
ifeq ($(shell uname),Darwin)
LIBCURS = ncurses
endif

else
# Include path for curses or ncurses (non-Unicode).
INCLUDES = -I/usr/include/ncurses
LIBCURS  = ncurses
endif

ifeq ($(LUASRC),)
LUASRC := util/lua/src
endif

LUALIB = lua
LUALIBA = l$(LUALIB).a

DBH_FILE  := /usr/include/db.h
NDBM_FILE := /usr/include/ndbm.h

HAVE_DBH  := $(shell [ -f $(DBH_FILE) ] && echo y)
HAVE_NDBM := $(shell [ -f $(NDBM_FILE) ] && echo y)

ifeq ($(HAVE_DBH),y)
ifneq ($(shell grep dbm_open $(DBH_FILE)),)
SELDBM := -DDB_DBH
LIBDBM := -ldb
endif
endif

ifeq ($(HAVE_NDBM),y)
SELDBM ?= -DDB_NDBM
ifeq ($(SELDBM),-DDB_NDBM)
LIBDBM := -ldbm
endif
endif

SQLSRC   := util/sqlite
SQLLIB   := sqlite3
SQLLIBA  := lib$(SQLLIB).a
FSQLLIBA := $(SQLSRC)/$(SQLLIBA)

ifeq ($(LIBDBM),)
LIBDBM         := -L$(SQLSRC) -lsqlite3
EXTRA_INCLUDES += -I$(SQLSRC)
EXTRA_DEPENDS  += $(FSQLLIBA)
endif

LIB = -l$(LIBCURS) -L$(LUASRC) -l$(LUALIB) $(LIBDBM)

INCLUDES := $(INCLUDES) -Iutil -I. -I$(LUASRC) $(EXTRA_INCLUDES)

CFWARN := -Wall -Wwrite-strings \
	-Wshadow -pedantic

CFOTHERS := -fsigned-char -D$(OS_TYPE) $(EXTRA_FLAGS)

ifneq ($(SAVEDIR),)
CFOTHERS += '-DSAVE_DIR_PATH="$(SAVEDIR)"'
endif

ifneq ($(DATADIR),)
CFOTHERS += '-DDATA_DIR_PATH="$(DATADIR)"'
endif

CFOTHERS += $(SELDBM)

CFLAGS  := $(INCLUDES) $(CFWARN) $(CFOTHERS)
YCFLAGS := $(INCLUDES) $(CFOTHERS)

UTIL = util/

YTABC  := levcomp.tab.c
YTABH  := levcomp.tab.h

OBJECTS := $(UTIL)levcomp.tab.o $(UTIL)levcomp.lex.o $(OBJECTS)

ifeq ($(LEX),)
DOYACC :=
endif

ifeq ($(YACC),)
DOYACC :=
endif

GAME_DEPENDS := $(EXTRA_DEPENDS) $(OBJECTS)
SRC_PKG_BASE := stone_soup
SRC_VERSION  := $(shell egrep 'VER_NUM  *".*"' version.h | \
			egrep -o '[0-9]\.[0-9](\.[0-9])?')
PKG_SRC_DIR  := $(SRC_PKG_BASE)-$(SRC_VERSION)-src
SRC_PKG_TAR  := $(PKG_SRC_DIR).tbz2
SRC_PKG_ZIP  := $(PKG_SRC_DIR).zip

PKG_TIDY_LIST := $(UTIL)*.o $(LEVCOMP) *.o \
		$(UTIL)*.tab.cc $(UTIL)*.tab.h $(UTIL)*.lex.cc *.ixx
PKG_EXCLUDES  := $(PWD)/misc/src-pkg-excludes.lst

##########################################################################

all: $(GAME)

##########################################################################
# Dependencies

DEPENDENCY_MKF := makefile.dep

depend: $(OBJECTS:.o=.cc)
	rm -f $(DEPENDENCY_MKF)
	@for i in $^; do \
	    echo "Updating dependencies for $$i"; \
	    $(CXX) -MM $(CFLAGS) $$i >>$(DEPENDENCY_MKF) 2>/dev/null; \
	done

-include $(DEPENDENCY_MKF)

##########################################################################
# The level compiler
#

ifeq ($(DOYACC),y)

prebuildyacc:	$(UTIL)levcomp.tab.cc $(UTIL)levcomp.tab.h $(UTIL)levcomp.lex.cc
		cp $^ prebuilt/

$(UTIL)levcomp.tab.cc: $(UTIL)levcomp.ypp
		cd $(UTIL) && $(YACC) -d -b levcomp levcomp.ypp \
			   && mv $(YTABC) levcomp.tab.cc || false

$(UTIL)levcomp.lex.cc: $(UTIL)levcomp.lpp
		cd $(UTIL) && $(LEX) -olevcomp.lex.cc levcomp.lpp

else

# Pull the level-compiler stuff up from prebuilt/

$(UTIL)levcomp.tab.cc: prebuilt/levcomp.tab.cc
		cp prebuilt/*.h $(UTIL)
		cp $< $@


$(UTIL)levcomp.lex.cc: prebuilt/levcomp.lex.cc
		cp $< $@

endif

##########################################################################


##########################################################################
# The actual build targets
#

install: $(GAME)
	[ -d $(INSTALLDIR) ] || mkdir -p $(INSTALLDIR)
	$(COPY) $(GAME) $(INSTALLDIR)
	chown $(INSTALL_UGRP) $(INSTALLDIR)/$(GAME)
	chmod ${MCHMOD} ${INSTALLDIR}/$(GAME)
ifeq ($(DATADIR),)
	$(error DATADIR not set! Set DATADIR and run make clean install again)
endif
	mkdir -p $(DATADIR)/dat/clua
	cp dat/*.des $(DATADIR)/dat
	cp dat/*.txt $(DATADIR)/dat
	cp dat/clua/*.lua $(DATADIR)/dat/clua
	cp -r lua $(DATADIR)/dat
	mkdir -p $(DATADIR)/docs
	cp ../docs/*.txt $(DATADIR)/docs
	chown -R $(INSTALL_UGRP) $(DATADIR)
ifneq ($(SAVEDIR),)
	mkdir -p $(SAVEDIR)
	chown $(INSTALL_UGRP) $(SAVEDIR)
	chmod $(MCHMOD_SAVEDIR) $(SAVEDIR)
endif
	ln -s $(INSTALLDIR)/$(GAME) /usr/local/bin/

clean:
	$(DELETE) *.o
	$(DELETE) $(UTIL)*.o
	$(DELETE) $(LEVCOMP)
	$(DELETE) $(UTIL)*.tab.cc $(UTIL)*.tab.c $(UTIL)*.tab.h $(UTIL)*.lex.cc
	$(DELETE) *.ixx

clean-lua:
	cd $(LUASRC) && $(MAKE) clean

clean-sql:
	cd $(SQLSRC) && $(MAKE) clean

distclean: clean clean-lua clean-sql
	$(DELETE) bones.*
	$(DELETE) morgue.txt
	$(DELETE) scores
	$(DELETE) $(GAME)
	$(DELETE) *.sav
	$(DELETE) core
	$(DELETE) *.0*
	$(DELETE) *.lab
	$(DELETE) $(DEPENDENCY_MKF)

$(GAME): $(LUASRC)$(LUALIBA) $(GAME_DEPENDS)
	${CXX} ${LDFLAGS} $(CFLAGS) $(OBJECTS) -o $(GAME) $(LIB)

debug: $(GAME_DEPENDS)
	${CXX} ${LDFLAGS} $(CFLAGS) $(OBJECTS) -o $(GAME) $(LIB)

profile: $(GAME_DEPENDS)
	${CXX} -g -p ${LDFLAGS} $(CFLAGS) $(OBJECTS) -o $(GAME) $(LIB)

.cc.o:
	${CXX} ${CFLAGS} -c $<

# [ds] Note we don't use the standard CFLAGS here; that's intentional, most
# flex/bison combos I've tried don't produce code that passes the warnings
# test.
$(UTIL)%.o: $(UTIL)%.cc
	$(CXX) $(YCFLAGS) -o $@ -c $<

#############################################################################
# Build Lua

$(LUASRC)$(LUALIBA):
	echo Building Lua...
	cd $(LUASRC) && $(MAKE) crawl_unix

#############################################################################
# Build SQLite

$(FSQLLIBA):
	echo Building SQLite
	cd $(SQLSRC) && $(MAKE)

#############################################################################
# Packaging a source tarball for release
#

# To package, you *must* have lex and yacc to generate the intermediates.
ifeq ($(DOYACC),y)
package-source: distclean prebuildyacc pkgtidy depend removeold vlink \
				pkgtarbz2 pkgzip

pkgtidy:
	$(DELETE) $(PKG_TIDY_LIST)

removeold:
	if [ -f ../../$(SRC_PKG_TAR) ]; then $(DELETE) ../../$(SRC_PKG_TAR); fi
	if [ -f ../../$(SRC_PKG_ZIP) ]; then $(DELETE) ../../$(SRC_PKG_ZIP); fi

# [ds] Existing directory names could produce a bad package!
vlink:
	cd .. && WHERE=$$PWD && cd .. && \
		( [ -e $(PKG_SRC_DIR) ] || ln -sf $$WHERE $(PKG_SRC_DIR) )

pkgtarbz2:
	cd ../.. && tar -ch --bzip2 -f $(SRC_PKG_TAR) \
		-X $(PKG_EXCLUDES) $(PKG_SRC_DIR)

pkgzip:
	cd ../.. && zip -rq $(SRC_PKG_ZIP) $(PKG_SRC_DIR) \
		-x@$(PKG_EXCLUDES)

endif
