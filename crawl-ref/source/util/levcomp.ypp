%{

#include "AppHdr.h"
#include "libutil.h"
#include "levcomp.h"
#include "mapdef.h"
#include "stuff.h"
#include <map>

#define YYERROR_VERBOSE 1

int yylex();

extern int yylineno;

struct map_file_place
{
    std::string filename;
    int lineno;

    map_file_place(const std::string &s = "", int line = 0)
        : filename(s), lineno(line)
    {
    }
};

typedef std::map<std::string, map_file_place> map_load_info_t;

static map_load_info_t loaded_maps;

void yyerror(const char *e)
{
    fprintf(stderr, "%s:%d: %s\n", lc_desfile.c_str(), yylineno, e);
    // Bail bail bail.
    end(1);
}

level_range set_range(const char *s, int start, int end)
{
    try
    {
        lc_range.set(s, start, end);
    }
    catch (const std::string &err)
    {
        yyerror(err.c_str());
    }
    return (lc_range);
}

%}

%union
{
    int i;
    const char *text;
    raw_range range;
}

%token <i>      BRANCHDEF BRANCH DESC DEFAULT
%token <i>      DEFAULT_DEPTH SHUFFLE SUBST TAGS KFEAT KITEM KMONS
%token <i>      NAME DEPTH ORIENT PLACE CHANCE FLAGS MONS ITEM
%token <i>      ROOT_DEPTH ENTRY_MSG EXIT_MSG
%token <i>      ROCK_COLOUR FLOOR_COLOUR
%token <i>      ENCOMPASS FLOAT 
%token <i>      NORTH EAST SOUTH WEST
%token <i>      NORTHEAST SOUTHEAST SOUTHWEST NORTHWEST

%token <i>      LEVEL END PVAULT PMINIVAULT MONSTERS ENDMONSTERS

%token <i>      CHARACTER

%token <i>      NO_HMIRROR NO_VMIRROR NO_ROTATE

%token <i>      PANDEMONIC 
%token <i>      DASH COMMA QUOTE OPAREN CPAREN COLON STAR NOT
%token <i>      INTEGER

%type  <i>      orient_name flagname
%type  <range>  lev_range ext_range

%token <text>   STRING MAP_LINE MONSTER_NAME ITEM_INFO
%token <text>   IDENTIFIER

%%

file            : definitions { }
                ;

definitions     : /* empty */               {}
                | definitions definition    {}
                ;

definition      : def       {}
                | level     {}
                ;

def             : defdepth  {}
                ;

defdepth        : DEFAULT_DEPTH 
                  { lc_default_depths.clear(); }
                  default_depth_ranges
                ;

level           : name metalines map_def metalines
                {
                    if (lc_map.orient == MAP_FLOAT
                        || lc_map.is_minivault())
                    {
                        if (lc_map.map.width() > GXM - MAPGEN_BORDER * 2
                            || lc_map.map.height() > GYM - MAPGEN_BORDER * 2)
                        {
                            char buf[300];
                            snprintf(buf, sizeof buf, 
                                 "%s is too big: %dx%d - max %dx%d",
                                 lc_map.is_minivault()? "Minivault" : "Float",
                                 lc_map.map.width(), lc_map.map.height(),
                                 GXM - MAPGEN_BORDER * 2,
                                 GYM - MAPGEN_BORDER * 2);
                            yyerror(buf);
                        }
                    }
                    else
                    {
                        if (lc_map.map.width() > GXM
                            || lc_map.map.height() > GYM)
                        {
                            char buf[300];
                            snprintf(buf, sizeof buf, 
                                 "Map is too big: %dx%d - max %dx%d",
                                 lc_map.map.width(), lc_map.map.height(),
                                 GXM, GYM);
                            yyerror(buf);
                        }
                    }

                    if (lc_map.map.height() == 0)
                        yyerror("Must define map.");

                    if (!lc_map.has_depth() && !lc_default_depths.empty())
                        lc_map.add_depths(lc_default_depths.begin(),
                                          lc_default_depths.end());

                    add_parsed_map( lc_map );
                }
                ;

name            : NAME STRING
                {
                    lc_map.init();
                    lc_map.name = $2;

                    map_load_info_t::const_iterator i = 
                        loaded_maps.find($2);

                    if (i != loaded_maps.end())
                    {
                        yyerror(
                            make_stringf(
                                "Map named '%s' already loaded at %s:%d",
                                $2,
                                i->second.filename.c_str(),
                                i->second.lineno).c_str() );
                    }

                    loaded_maps[$2] = map_file_place(lc_desfile, yylineno);
                }
                ;

metalines       : /* no metadata */
                | metaline metalines
                ;

metaline        : place
                | depth
                | chance
                | orientation
                | flags
                | mons
                | items
                | subst
                | tags
                | shuffle
                | kfeat
                | kitem
                | kmons
                ;

kfeat           : KFEAT { }
                | KFEAT STRING
                {
                    std::string err = lc_map.add_key_feat($2);
                    if (!err.empty())
                        yyerror(
                            make_stringf("Bad arg to KFEAT: '%s' (%s)",
                                $2, err.c_str()).c_str());
                }

kmons           : KMONS { }
                | KMONS STRING
                {
                    std::string err = lc_map.add_key_mons($2);
                    if (!err.empty())
                        yyerror(
                            make_stringf("Bad arg to KMONS: '%s' (%s)",
                                $2, err.c_str()).c_str());
                }

kitem           : KITEM { }
                | KITEM STRING
                {
                    std::string err = lc_map.add_key_item($2);
                    if (!err.empty())
                        yyerror(
                            make_stringf("Bad arg to KITEM: '%s' (%s)",
                                $2, err.c_str()).c_str());
                }

shuffle         : SHUFFLE shuffle_specifiers {} 
                ;

shuffle_specifiers : shuffle_spec
                   | shuffle_specifiers COMMA shuffle_spec
                   ;

shuffle_spec    : ITEM_INFO
                {
                    std::string err = lc_map.map.add_shuffle($1);
                    if (!err.empty())
                        yyerror(
                            make_stringf(
                                "Bad shuffle argument: '%s' (%s)",
                                $1, err.c_str() ).c_str() );
                }

tags            : TAGS tagstrings {}
                ;

tagstrings      : /* empty */
                | STRING tagstrings
                {
                    lc_map.tags += " ";
                    lc_map.tags += $1;
                    lc_map.tags += " ";
                }
                ;

subst           : SUBST subst_specifiers { }
                ;

subst_specifiers : subst_spec
                 | subst_spec COMMA subst_specifiers
                 ;

subst_spec      : ITEM_INFO
                {
                    std::string err = lc_map.map.add_subst($1);
                    if (!err.empty())
                        yyerror(
                            make_stringf(
                                "Bad SUBST argument: '%s' (%s)",
                                $1, err.c_str() ).c_str() );
                }
                ;

items           : ITEM {}
                | ITEM item_specifiers {}
                ;

item_specifiers : item_specifier COMMA item_specifiers
                | item_specifier
                ;

item_specifier  : ITEM_INFO
                {
                    std::string error = lc_map.items.add_item($1);
                    if (error.size())
                    {
                        char errbuf[300];
                        snprintf(errbuf, sizeof errbuf,
                            "Invalid item descriptor: '%s' (%s)",
                                $1, error.c_str());
                        yyerror(errbuf);
                    }
                    if (lc_map.items.size() > 8)
                        yyerror("Too many items specified (max 8)");
                }
                
mons            : MONS {}
                | MONS mnames {}
                ;

mnames          : mname COMMA mnames
                | mname
                ;

mname           : MONSTER_NAME
                {
                    std::string err = lc_map.mons.add_mons($1);
                    if (!err.empty())
                    {
                        char buf[300];
                        snprintf(buf, sizeof buf, 
                                 "bad monster spec '%s' (%s)",
                                 $1, err.c_str());
                        yyerror(buf);
                    }
                    if (lc_map.mons.size() > 7)
                        yyerror("Too many monsters specified (max 7)");
                }
                ;

place           : PLACE STRING
                {
                    lc_map.place = $2;
                }
                ;

depth           : DEPTH {}
                | DEPTH extended_depth_ranges {}
                ;

default_depth_ranges : 
                ext_range
                {
                    lc_default_depths.push_back($1);
                }

                | default_depth_ranges COMMA ext_range
                {
                    lc_default_depths.push_back($3);
                }
                ;

extended_depth_ranges : 
                ext_range
                {
                    lc_map.add_depth($1);
                }

                | extended_depth_ranges COMMA ext_range
                {
                    lc_map.add_depth($3);
                }
                ;

ext_range       : lev_range     { $$ = $1; }
                | NOT lev_range { $$ = $2; $$.deny = true; }
                ;

lev_range       : IDENTIFIER
                {
                    $$ = set_range($1, 1, 100);
                }

                | IDENTIFIER COLON STAR
                {
                    $$ = set_range($1, 1, 100);
                }

                | IDENTIFIER COLON INTEGER DASH INTEGER
                {
                    $$ = set_range($1, $3, $5);
                }

                | IDENTIFIER COLON INTEGER
                {
                    $$ = set_range($1, $3, $3);
                }

                | INTEGER DASH INTEGER
                {
                    $$ = set_range("Any", $1, $3);
                }

                | INTEGER
                {
                    $$ = set_range("Any", $1, $1);
                }
                ;

chance          : CHANCE INTEGER
                {
                    lc_map.chance = $2;
                }
                ;

orientation     : ORIENT {}
                | ORIENT orient_name
                {
                    lc_map.orient = (map_section_type) $2;
                }
                ;

orient_name     : ENCOMPASS     { $$ = MAP_ENCOMPASS; }
                | NORTH         { $$ = MAP_NORTH; }
                | EAST          { $$ = MAP_EAST; }
                | SOUTH         { $$ = MAP_SOUTH; }
                | WEST          { $$ = MAP_WEST; }
                | NORTHEAST     { $$ = MAP_NORTHEAST; }
                | SOUTHEAST     { $$ = MAP_SOUTHEAST; }
                | SOUTHWEST     { $$ = MAP_SOUTHWEST; }
                | NORTHWEST     { $$ = MAP_NORTHWEST; }
                | FLOAT         { $$ = MAP_FLOAT; }
                ;

flags           : FLAGS flagnames {}
                ;

flagnames       : /* empty */
                | flagname flagnames
                {
                    switch ($1) {
                    case NO_HMIRROR:
                        lc_map.flags &= ~MAPF_MIRROR_HORIZONTAL;
                        break;
                    case NO_VMIRROR:
                        lc_map.flags &= ~MAPF_MIRROR_VERTICAL;
                        break;
                    case NO_ROTATE:
                        lc_map.flags &= ~MAPF_ROTATE;
                        break;
                    }
                }
                ;

flagname        : NO_HMIRROR    { $$ = NO_HMIRROR; }
                | NO_VMIRROR    { $$ = NO_VMIRROR; }
                | NO_ROTATE     { $$ = NO_ROTATE;  }
                ;

map_def         : map_lines
                ;

map_lines       : map_line
                | map_line map_lines
                ;

map_line        : MAP_LINE
                {
                    lc_map.map.add_line($1);
                }
                ;

%%
