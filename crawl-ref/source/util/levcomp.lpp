%{

// levcomp.lpp:
//      Level compiler lexer for Dungeon Crawl Stone Soup.
// 
// Based loosely on NetHack's lev_comp.l

#include "AppHdr.h"
#include "levcomp.tab.h"
#include <cstring>
#include <queue>

static bool alloced = false;

std::queue<const char *> free_queue;

static void flush_free_queue(unsigned int max_allowed)
{
    while (free_queue.size() > max_allowed)
    {
        const char *s = free_queue.front();
        free((void *) s);
        free_queue.pop();
    }
}

static void add_to_queue(const char *s)
{
    free_queue.push(s);
    flush_free_queue(20);
}

static void clean()
{
    if (yylval.text && alloced)
        add_to_queue(yylval.text);
    yylval.text = NULL;
    alloced = false;
}

static void settext()
{
    clean();
    if ((yylval.text = strdup(yytext)))
        alloced = true;
}

%}

%x MAPDEF
%s ARGUMENT
%s MNAME
%s KEYWORDS
%x ITEM_LIST

%option yylineno
%option never-interactive

NSPACE [^\ \t\r\n]

%%

<MAPDEF>^\s*ENDMAP  { BEGIN(INITIAL); }

<MAPDEF>^[^ \r\n\t]+ {
                        settext();
                        return MAP_LINE;
                    }

<MAPDEF>^[ ]*\r?\n      return CHARACTER;
<MAPDEF>#               return CHARACTER;
<MAPDEF>[\ ][^\ \r\n]   return CHARACTER;

<MAPDEF>[ ]*\r?\n       ;

<KEYWORDS>[A-Za-z_0-9\-]+   {
                        settext();
                        return STRING;
                    }

<KEYWORDS>[ \t]+    ;
<KEYWORDS>[ \t]*\r?\n  { BEGIN(INITIAL); }

<ITEM_LIST>[^, \t\r\n][^,\r\n]*[^, \t\r\n] { 
                        settext();
                        return ITEM_INFO;
                    }

<ITEM_LIST>[^, \t\r\n] {
                        settext();
                        return ITEM_INFO;
                    }

<ITEM_LIST>,            return COMMA;
<ITEM_LIST>[ \t]+       ;
<ITEM_LIST>[ \t]*\r?\n  { BEGIN(INITIAL); }

<MNAME>[\ \t\r]*\n  { BEGIN(INITIAL); }

<MNAME>[^,\ \t\r\n][^,\r\n]+[^,\ \t\r\n] { 
                        settext();
                        return MONSTER_NAME; 
                    }

<MNAME>,            return COMMA;
<MNAME>[ \t\r]+     ;

<ARGUMENT>{NSPACE}.*{NSPACE} { 
                        BEGIN(INITIAL);
                        settext();
                        return STRING; 
                    }

<ARGUMENT>\r?\n     { BEGIN(INITIAL); }

^[ \t]*#.*          ;

^\s*MAP                { BEGIN(MAPDEF); }


NAME:               { BEGIN(ARGUMENT); return NAME; }
default-depth:      return DEFAULT_DEPTH;
DEPTH:              return DEPTH;
ORIENT:             return ORIENT;
PLACE:              { BEGIN(ARGUMENT); return PLACE; }
CHANCE:             return CHANCE;
FLAGS:              return FLAGS;
TAGS:               { BEGIN(KEYWORDS); return TAGS; }
SUBST:              { BEGIN(ITEM_LIST); return SUBST; }
MONS:               { BEGIN(MNAME); return MONS; }
ITEM:               { BEGIN(ITEM_LIST); return ITEM; }
SHUFFLE:            { BEGIN(ITEM_LIST); return SHUFFLE; }

KFEAT:              { BEGIN(ARGUMENT); return KFEAT; }
KITEM:              { BEGIN(ARGUMENT); return KITEM; }
KMONS:              { BEGIN(ARGUMENT); return KMONS; }

BRANCHDEF:          return BRANCH;
DEFAULT             return DEFAULT;
DESC:               return DESC;
BRANCH:             return BRANCH;
ROOT_DEPTH:         return ROOT_DEPTH;
FLOOR_COLOUR:       return FLOOR_COLOUR;
ROCK_COLOUR:        return ROCK_COLOUR;

LEVEL             return LEVEL;
END               return END;
PVAULT:             return PVAULT;
PMINIVAULT:         return PMINIVAULT;

ENTRY_MSG:          { BEGIN(ARGUMENT); return ENTRY_MSG; }
EXIT_MSG:           { BEGIN(ARGUMENT); return EXIT_MSG; }

MONSTERS          return MONSTERS;
ENDMONSTERS       return ENDMONSTERS;


pandemonic          return PANDEMONIC;
no_hmirror          return NO_HMIRROR;
no_vmirror          return NO_VMIRROR;
no_rotate           return NO_ROTATE;

encompass           return ENCOMPASS;
north               return NORTH;
south               return SOUTH;
east                return EAST;
west                return WEST;
northeast           return NORTHEAST;
northwest           return NORTHWEST;
southeast           return SOUTHEAST;
southwest           return SOUTHWEST;
float               return FLOAT;

-                   return DASH;
,                   return COMMA;

[0-9]+              {
                        clean();
                        yylval.i = atoi(yytext);
                        return INTEGER;
                    }

[\ \t]+             ;
\r?\n               ;

\(                   return OPAREN;
\)                   return CPAREN;

\"                  return QUOTE;

[a-zA-Z_][a-zA-Z_0-9]+ {
                        settext();
                        return IDENTIFIER;
                    }

.                   return CHARACTER;

%%

int yywrap()
{
    clean();
    flush_free_queue(0);
    return 1;
}
